import { SetComplement, DeepReadonly } from './mapped-types';
export declare type $Keys<T extends object> = keyof T;
export declare type $Values<T extends object> = T[keyof T];
export declare type $ReadOnly<T extends object> = DeepReadonly<T>;
export declare type $Diff<T extends U, U extends object> = Pick<T, SetComplement<keyof T, keyof U>>;
export declare type $PropertyType<T extends object, K extends keyof T> = T[K];
export declare type $ElementType<T extends {
    [P in K & any]: any;
}, K extends keyof T | number> = T[K];
export declare type $Call<Fn extends (...args: any[]) => any> = Fn extends (arg: any) => infer RT ? RT : never;
export declare type $Shape<T extends object> = Partial<T>;
export declare type $NonMaybeType<T> = NonNullable<T>;
export declare type Class<T> = new (...args: any[]) => T;
